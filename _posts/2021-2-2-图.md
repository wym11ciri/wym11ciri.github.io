---
layout: post
title:  "最小生成树-dijkstra,floyd"
date:   2021-2-2 14:05:21 +0800
tags: c++
color: rgb(255,90,90)
cover: '../assets/test.png'
---

### Dijkstra  
单源最短路径问题  图为邻接矩阵表示

标志数组 //n个顶点

final[n] 当点V到Vi的最短路径求出时为1，默认为0

dist[n]  dist[i]存放V到Vi的最短路径长度

path[n]  存放V到Vi的最短路径（可以理解为上一跳地址，从哪个点过来的）

第1轮：循环遍历所有结点，找到还没确定最短路径的结点，且dist为最小的顶点Vi，令final[i] = true

检查所有邻接自Vi的顶点，若其final值为false，则更新dist和path信息。

第2轮：同第一轮

共n-1轮，每一轮处理循环遍历final数组（找到dist最小的且final为false的顶点），故时间复杂度 O(n^2)

Dijkstra不适用于带有负权图的边。因为找到最小dist值的那一步，是贪心的思想，找到最小dist就立刻把final设为1了。如果<b>不是最小dist值</b>的后面再有负权路径，是检测不到的。

与prim的相似之处：都是选点加入集合

### Floyd(堆排序也是这人发明的)

动态规划   求出每一对顶点之间的最短路径

维护一个path矩阵存放路径

对于n个顶点的图G，求任意一对顶点 Vi->Vj之间的最短路径可分为如下几个阶段：

·初始：不允许在其他顶点中转，最短路径是？

·0：允许在V0中转，最短路径是？ 

·1：允许在V0，V1中转呢

…

·n-1：允许在V0，V1，V2……Vn-1中转，最短路径是？

n轮递推，每次遍历一次二维矩阵(也就是开始的邻接矩阵)，故时间复杂度为O(n^3)

代码比较简单所以放上

```
for(int k = 0; k < n; k++){
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            if(A[i][j] > A[i][k] + A[k][j]){ //如果以Vk为中转点，从Vi到Vj的路径更短
                A[i][j] = A[i][k] + A[k][j];
                path[i][j] = k; //i到j经过k
            }
        }
    }
}
```
